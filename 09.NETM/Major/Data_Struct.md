# Data Struct

## 算法及效率

1. 算法
    1. 有穷性
    2. 确定性
    3. 可行性
    4. 输入
    5. 输出

2. 算法设计
    1. 正确性
    2. 可读性
    3. 健壮性
    4. 效率与低存储量

3. 算法效率
    1. <渐近>时间复杂度`T(n)=O(f(n))` P15

        O(1), O(n), O($n^2$), O($\log{2}$⁡), O($2^n$)  
        分别为
        常量阶，线性阶，平方阶，对数阶，指数阶

        - 时间复杂度O(1)

        `x++;`

        - 时间复杂度O(n)

        ``` c
        for (i = 1; i < n; i++){
            x++;
        }
        ```

        - 时间复杂度O(n^2 )

        ```c
        for (i = 1; i < n; i++){
            for (j = 1; j < n; j++){
                x++;
            }
        }
        ```
    2. 空间复杂度`S(n)=O(f(n))` P17

## 线性表

## 栈

## 队列

## 串

## 数组

## 广义表

## 数

## 二叉树

## 图

## 动态存储

## 查找

## 内部排序

## 外部排序

## 文件

# 排序算法

## 冒泡排序

1. 从第一个元素开始比较相邻的元素。如果前一个比后一个大，就交换它们两个；
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对；
3. 针对所有的元素重复以上的步骤，除了最后一个；
    (第n轮之后可以确定排在倒数第n个元素值当前最大，则第n+1轮开始不对倒数第n个元素及排位大于n的元素排序)
4. 重复步骤1~3，直到排序完成。
    ```
    4 2 3 1 *
    2 3 1 * 4
    2 1 * 3 4
    1 * 2 3 4
    ```
    ```c
    int main()
    {
            int i, j;
            int list[5]={5,2,5,3,1};

    }
    ```


## 选择排序

## 插入排序

## 希尔排序

## 归并排序

## 归并排序

## 快速排序

## 堆排序

## 计数排序（可选）

## 桶排序（可选）

## 基数排序
